


import type { ToolCreatorPayload } from '../types';

export const DATA_RECORDER_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'RecordRefinedQueries',
        description: 'Records a list of specific search queries generated by the AI.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a list of search queries. This is called once by the query refinement agent.',
        parameters: [
            { name: 'queries', type: 'array', description: 'An array of specific, database-optimized search query strings.', required: true },
        ],
        implementationCode: `
            const { queries } = args;
            if (!queries || !Array.isArray(queries) || queries.length === 0) {
                throw new Error("An array of queries must be provided.");
            }
            runtime.logEvent(\`[Query Refinement] Recording \${queries.length} queries: \${queries.join('; ')}\`);
            return { success: true, queries };
        `
    },
    {
        name: 'RecordValidatedSource',
        description: 'Records the details of a single validated and summarized scientific source.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single validated source. This is called iteratively by the validation agent to build a list of trusted sources.',
        parameters: [
            { name: 'uri', type: 'string', description: 'The unique URL or identifier for the source.', required: true },
            { name: 'title', type: 'string', description: 'The title of the article.', required: true },
            { name: 'summary', type: 'string', description: 'A concise summary of the article\'s key findings relevant to the research objective.', required: true },
            { name: 'reliability', type: 'number', description: 'A score from 0.0 to 1.0 indicating the source\'s scientific reliability.', required: true },
            { name: 'reliabilityJustification', type: 'string', description: 'A brief justification for the assigned reliability score.', required: true },
        ],
        implementationCode: `
            const { ...validatedSourceData } = args;
            runtime.logEvent(\`[Validator] Recording validated source: \${validatedSourceData.title}\`);
            
            return {
                success: true,
                validatedSource: validatedSourceData
            };
        `
    },
    {
        name: 'RecordMetaAnalysis',
        description: 'Records that a specific source has been classified as a meta-analysis or review.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single source identified as a meta-analysis during the classification step.',
        parameters: [
            { name: 'source', type: 'object', description: 'The full source object that has been identified as a meta-analysis.', required: true },
        ],
        implementationCode: `
            const { source } = args;
            runtime.logEvent(\`[Classifier] Recording Meta-Analysis: \${source.title}\`);
            return { success: true, metaAnalysis: source };
        `
    },
    {
        name: 'RecordPrimaryStudy',
        description: 'Records that a specific source has been classified as a primary study.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single source identified as a primary study during the classification step.',
        parameters: [
            { name: 'source', type: 'object', description: 'The full source object that has been identified as a primary study.', required: true },
        ],
        implementationCode: `
            const { source } = args;
            runtime.logEvent(\`[Classifier] Recording Primary Study: \${source.title}\`);
            return { success: true, primaryStudy: source };
        `
    },
    {
        name: 'RecordSynergy',
        description: 'Records the details of a single synergistic intervention identified from the literature.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single identified synergy, which the agent calls iteratively. This avoids generating and parsing a large, complex JSON array.',
        parameters: [
            { name: 'combination', type: 'array', description: 'An array of strings representing the interventions in the synergy (e.g., ["Metformin", "Rapamycin"]).', required: true },
            { name: 'status', type: 'string', description: 'The status of the synergy, either "Known" or "Hypothesized".', required: true },
            { name: 'synergyType', type: 'string', description: 'The type of interaction, e.g., "Synergistic", "Additive", "Antagonistic".', required: true },
            { name: 'summary', type: 'string', description: 'A brief explanation of the synergistic interaction and the rationale behind it.', required: true },
            { name: 'potentialRisks', type: 'string', description: 'A clear description of potential risks, side effects, or contraindications of the combination.', required: true },
        ],
        implementationCode: `
            const { combination, status, synergyType, summary, potentialRisks } = args;
            runtime.logEvent(\`[Synergy Analysis] Recording synergy: \${combination.join(' + ')}\`);
            
            return {
                success: true,
                synergy: {
                    combination,
                    status,
                    synergyType,
                    summary,
                    potentialRisks,
                }
            };
        `
    },
    {
        name: 'RecordSynergyGameParameters',
        description: 'Records the mapping of a single synergy to the specific parameters of the Organoid Odyssey simulator.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log the game parameters for a single synergy by calling a tool with explicit, flattened parameters, which is more reliable for AI.',
        parameters: [
            { name: 'synergyCombination', type: 'array', description: 'The array of intervention names that identifies the synergy (e.g., ["Metformin", "Rapamycin"]).', required: true },
            { name: 'senolytic_clearance', type: 'number', description: 'Value from 0.0 to 100.0 representing senescent cell clearance.', required: false },
            { name: 'autophagy_boost', type: 'number', description: 'Multiplier for autophagy effectiveness (e.g., 1.2 for a 20% boost).', required: false },
            { name: 'antioxidant_capacity_boost', type: 'number', description: 'Multiplier for antioxidant capacity (e.g., 1.5 for a 50% boost).', required: false },
            { name: 'dna_repair_rate_boost', type: 'number', description: 'Multiplier for DNA repair rate (e.g., 1.1 for a 10% boost).', required: false },
            { name: 'epigenetic_reset_value', type: 'number', description: 'Value from 0.0 to 100.0 for direct reduction in epigenetic noise.', required: false },
            { name: 'epigenetic_stabilization', type: 'number', description: 'Multiplier for epigenetic stability (e.g., 1.2 for a 20% improvement).', required: false },
            { name: 'signaling_pathway_inhibition', type: 'number', description: 'Multiplier for inhibiting harmful developmental signals (e.g., 1.15 for 15% inhibition).', required: false },
            { name: 'synaptic_density_boost', type: 'number', description: 'Value from 0.0 to 100.0 for direct increase in synaptic density.', required: false },
            { name: 'toxicity_impact', type: 'number', description: 'Value from 0.0 to 100.0 representing the negative health impact or toxicity.', required: false },
        ],
        implementationCode: `
            const { synergyCombination, ...rest } = args;
            
            const gameParameters = {};
            for (const key in rest) {
                if (rest[key] !== null && rest[key] !== undefined) {
                    gameParameters[key] = rest[key];
                }
            }

            // FIX: Ensure synergyCombination is an array before using .join() and for the return value
            const finalCombination = Array.isArray(synergyCombination) ? synergyCombination : (synergyCombination ? [String(synergyCombination)] : []);

            if (finalCombination.length === 0 || (finalCombination.length === 1 && !finalCombination[0])) {
                throw new Error("A synergyCombination array is required.");
            }

            runtime.logEvent(\`[Game Data] Recording parameters for: \${finalCombination.join(' + ')}\`);

            return {
                success: true,
                synergyCombination: finalCombination,
                gameParameters,
            };
        `
    },
    {
        name: 'RecordTrialDossier',
        description: 'Records a complete, trial-ready dossier for a specific combination, intended for business and investment review.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To capture the structured output of the "Business Analyst" agent, turning research findings into an actionable investment proposal.',
        parameters: [
            { name: 'combination', type: 'array', description: 'The array of intervention names.', required: true },
            { name: 'executiveSummary', type: 'string', description: 'A high-level summary for investors.', required: true },
            { name: 'scientificRationale', type: 'string', description: 'Detailed explanation of the biological mechanism and synergy.', required: true },
            { name: 'inSilicoValidation', type: 'string', description: 'The results from the SynergyForge simulation, presented as evidence. E.g., "Predicted healthspan increase of 45% (p<0.001, n=1000) across 3 of 4 aging models."', required: true },
            { name: 'marketAndIP', type: 'string', description: 'Analysis of the market opportunity and potential for intellectual property.', required: true },
            { name: 'roadmap', type: 'string', description: 'Proposed next steps, e.g., preclinical animal studies.', required: true },
            { name: 'risks', type: 'string', description: 'An analysis of known risks and potential side effects.', required: true },
        ],
        implementationCode: `
            const { ...dossierData } = args;
            
            // FIX: Add robustness for 'combination' argument which might not be an array.
            const combination = dossierData.combination;
            const finalCombination = Array.isArray(combination) ? combination : (combination ? [String(combination)] : []);

            if (finalCombination.length === 0 || (finalCombination.length === 1 && !finalCombination[0])) {
                throw new Error("A combination of interventions is required for a dossier.");
            }
            
            runtime.logEvent(\`[Dossier] Recording investment proposal for: \${finalCombination.join(' + ')}\`);
            
            // Ensure the dossier object has the corrected array format
            dossierData.combination = finalCombination;

            return {
                success: true,
                dossier: dossierData,
            };
        `
    },
    {
        name: 'RecordCritique',
        description: 'Records the structured output from the Critique Investment Proposal tool.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log the final critique of a proposal, making it available for the UI to display.',
        parameters: [
             { name: 'combination', type: 'array', description: 'The combination of interventions being critiqued.', required: true },
             // FIX: Reverted to single-quoted strings to resolve a build system parsing issue with template literals in this context. Escaped the apostrophe.
             { name: 'strengths', type: 'string', description: 'A summary of the proposal\'s strong points.', required: true },
             { name: 'weaknesses', type: 'string', description: 'A summary of the proposal\'s weaknesses and understated risks.', required: true },
             { name: 'contradictoryEvidence', type: 'array', description: 'An array of strings, where each string is a piece of evidence that contradicts the proposal.', required: true },
             { name: 'overallVerdict', type: 'string', description: 'The final verdict, must be one of: "Sound", "Needs Revision", or "High Risk".', required: true },
        ],
        implementationCode: `
        const { ...critiqueData } = args;
        if (!critiqueData.combination || !critiqueData.overallVerdict) {
            throw new Error("Critique data is missing required fields 'combination' or 'overallVerdict'.");
        }
        runtime.logEvent(\`[Critique] Recording critique for: \${critiqueData.combination.join(' + ')}\`);
        return { success: true, critique: critiqueData };
    `
    },
    {
        name: 'RecordErrorAnalysis',
        description: 'Records the structured analysis of a tool execution error, as determined by the diagnostic supervisor agent.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a clear, structured log entry detailing the root cause and suggested fix for a system error, enabling better debugging and future self-healing capabilities.',
        parameters: [
            { name: 'failedToolName', type: 'string', description: 'The name of the tool or process that failed.', required: true },
            { name: 'errorCategory', type: 'string', description: 'The category of the error. Must be one of: MODEL_INCAPABLE, TOOL_BUG, PROMPT_AMBIGUITY, AGENT_LOGIC_ERROR.', required: true },
            { name: 'diagnosis', type: 'string', description: 'A detailed explanation of the reasoning behind the diagnosis.', required: true },
            { name: 'suggestedAction', type: 'string', description: 'The suggested recovery action. Must be one of: RETRY_WITH_STRONGER_MODEL, MODIFY_TOOL_CODE, REWRITE_PROMPT, SIMPLIFY_TASK.', required: true },
            { name: 'actionParameters', type: 'object', description: 'A JSON object containing the specific parameters for the suggested action (e.g., {"suggestedModelId": "gemini-2.5-pro"}).', required: true },
        ],
        implementationCode: `
            const { failedToolName, errorCategory, diagnosis, suggestedAction, actionParameters } = args;
            
            const logMessage = \`
[SUPERVISOR] 💡 Diagnostic Report for '\${failedToolName}':
- Category: \${errorCategory}
- Action: \${suggestedAction}
- Parameters: \${JSON.stringify(actionParameters)}
- Diagnosis: \${diagnosis}
            \`;
            
            runtime.logEvent(logMessage);
            
            return {
                success: true,
                analysis: { failedToolName, errorCategory, diagnosis, suggestedAction, actionParameters }
            };
        `
    },
];

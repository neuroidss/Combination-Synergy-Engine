import type { ToolCreatorPayload } from '../types';

export const DATA_RECORDER_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'RecordRefinedQueries',
        description: 'Records a list of specific search queries generated by the AI.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a list of search queries. This is called once by the query refinement agent.',
        parameters: [
            { name: 'queries', type: 'array', description: 'An array of specific, database-optimized search query strings.', required: true },
        ],
        implementationCode: `
            const { queries } = args;
            if (!queries || !Array.isArray(queries) || queries.length === 0) {
                throw new Error("An array of queries must be provided.");
            }
            runtime.logEvent(\`[Query Refinement] Recording \${queries.length} queries: \${queries.join('; ')}\`);
            return { success: true, queries };
        `
    },
    {
        name: 'RecordValidatedSource',
        description: 'Records the details of a single validated and summarized scientific source.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single validated source. This is called iteratively by the validation agent to build a list of trusted sources.',
        parameters: [
            { name: 'uri', type: 'string', description: 'The unique URL or identifier for the source.', required: true },
            { name: 'title', type: 'string', description: 'The title of the article.', required: true },
            { name: 'summary', type: 'string', description: 'A concise summary of the article\'s key findings relevant to the research objective.', required: true },
            { name: 'reliability', type: 'number', description: 'A score from 0.0 to 1.0 indicating the source\'s scientific reliability.', required: true },
            { name: 'reliabilityJustification', type: 'string', description: 'A brief justification for the assigned reliability score.', required: true },
        ],
        implementationCode: `
            const { ...validatedSourceData } = args;
            runtime.logEvent(\`[Validator] Recording validated source: \${validatedSourceData.title}\`);
            
            return {
                success: true,
                validatedSource: validatedSourceData
            };
        `
    },
    {
        name: 'RecordMetaAnalysis',
        description: 'Records that a specific source has been classified as a meta-analysis or review.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single source identified as a meta-analysis during the classification step.',
        parameters: [
            { name: 'source', type: 'object', description: 'The full source object that has been identified as a meta-analysis.', required: true },
        ],
        implementationCode: `
            const { source } = args;
            runtime.logEvent(\`[Classifier] Recording Meta-Analysis: \${source.title}\`);
            return { success: true, metaAnalysis: source };
        `
    },
    {
        name: 'RecordPrimaryStudy',
        description: 'Records that a specific source has been classified as a primary study.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single source identified as a primary study during the classification step.',
        parameters: [
            { name: 'source', type: 'object', description: 'The full source object that has been identified as a primary study.', required: true },
        ],
        implementationCode: `
            const { source } = args;
            runtime.logEvent(\`[Classifier] Recording Primary Study: \${source.title}\`);
            return { success: true, primaryStudy: source };
        `
    },
    {
        name: 'RecordSynergy',
        description: 'Records the details of a single synergistic intervention, including MoA and Theory Alignment scores.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single identified synergy with its complete scoring profile, which the agent calls iteratively.',
        parameters: [
            { name: 'combination', type: 'array', description: 'An array of objects, each with "name" and "type". Types are "drug" (molecules, wetware), "device" (hardware, nanorobots), or "behavior" (algorithms, lifestyle). E.g., [{"name": "Metformin", "type": "drug"}, {"name": "Exercise", "type": "behavior"}]', required: true },
            { name: 'status', type: 'string', description: 'The status of the synergy, either "Known" or "Hypothesized".', required: true },
            { name: 'synergyType', type: 'string', description: 'The type of interaction, e.g., "Synergistic", "Additive", "Antagonistic".', required: true },
            { name: 'summary', type: 'string', description: 'A brief explanation of the synergistic interaction and the rationale behind it.', required: true },
            { name: 'potentialRisks', type: 'string', description: 'A clear description of potential risks, side effects, or contraindications of the combination.', required: true },
            { name: 'sourceUri', type: 'string', description: 'The URI of the source document where this synergy was found.', required: false },
            { name: 'sourceTitle', type: 'string', description: 'The title of the source document.', required: false },
            { name: 'moaComplementarityScore', type: 'number', description: 'A score from 0-100 representing how well the mechanisms of action complement each other. Provide 0 if not applicable.', required: false },
            { name: 'moaJustification', type: 'string', description: 'A brief scientific justification for the complementarity score. Provide "N/A" if not applicable.', required: false },
            { name: 'trialPriorityScore', type: 'number', description: 'The final calculated score (0-100) indicating the priority for a clinical trial.', required: false },
            { name: 'theoryAlignmentScores', type: 'object', description: 'An object containing scores for alignment with different aging theories (e.g., {"stochastic": 80}).', required: false },
        ],
        implementationCode: `
            const { combination, status, synergyType, summary, potentialRisks, sourceUri, sourceTitle, moaComplementarityScore, moaJustification, trialPriorityScore, theoryAlignmentScores } = args;

            if (!Array.isArray(combination) || combination.length === 0 || combination.some(c => typeof c !== 'object' || !c.name || !c.type)) {
                throw new Error("A synergy 'combination' is required and must be an array of objects, each with a 'name' and a 'type'.");
            }

            runtime.logEvent(\`[Synergy Analysis] Recording synergy: \${combination.map(c => c.name).join(' + ')}\`);
            
            return {
                success: true,
                synergy: {
                    combination,
                    status,
                    synergyType,
                    summary,
                    potentialRisks,
                    sourceUri,
                    sourceTitle,
                    moaComplementarityScore: moaComplementarityScore || 0,
                    moaJustification: moaJustification || 'N/A',
                    trialPriorityScore: trialPriorityScore || 0,
                    theoryAlignmentScores: theoryAlignmentScores || {},
                }
            };
        `
    },
    {
        name: 'RecordSynergyGameParameters',
        description: 'Records the mapping of a single synergy to the specific parameters of the Organoid Odyssey simulator.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log the game parameters for a single synergy by calling a tool with explicit, flattened parameters, which is more reliable for AI.',
        parameters: [
            { name: 'synergyCombination', type: 'array', description: 'The array of intervention names that identifies the synergy (e.g., ["Metformin", "Rapamycin"]).', required: true },
            { name: 'senolytic_clearance', type: 'number', description: 'Value from 0.0 to 100.0 representing senescent cell clearance.', required: false },
            { name: 'autophagy_boost', type: 'number', description: 'Multiplier for autophagy effectiveness (e.g., 1.2 for a 20% boost).', required: false },
            { name: 'antioxidant_capacity_boost', type: 'number', description: 'Multiplier for antioxidant capacity (e.g., 1.5 for a 50% boost).', required: false },
            { name: 'dna_repair_rate_boost', type: 'number', description: 'Multiplier for DNA repair rate (e.g., 1.1 for a 10% boost).', required: false },
            { name: 'epigenetic_reset_value', type: 'number', description: 'Value from 0.0 to 100.0 for direct reduction in epigenetic noise.', required: false },
            { name: 'epigenetic_stabilization', type: 'number', description: 'Multiplier for epigenetic stability (e.g., 1.2 for a 20% improvement).', required: false },
            { name: 'signaling_pathway_inhibition', type: 'number', description: 'Multiplier for inhibiting harmful developmental signals (e.g., 1.15 for 15% inhibition).', required: false },
            { name: 'synaptic_density_boost', type: 'number', description: 'Value from 0.0 to 100.0 for direct increase in synaptic density.', required: false },
            { name: 'toxicity_impact', type: 'number', description: 'Value from 0.0 to 100.0 representing the negative health impact or toxicity.', required: false },
            { name: 'myelin_repair_boost', type: 'number', description: 'Multiplier for myelin repair processes (e.g., 1.3 for a 30% boost).', required: false },
            { name: 'neurotransmitter_stabilization', type: 'number', description: 'Multiplier for neurotransmitter balance and efficiency (e.g., 1.2 for 20% improvement).', required: false },
            { name: 'dendritic_arborization_factor', type: 'number', description: 'Value from 0.0 to 100.0 for direct increase in dendritic complexity.', required: false },
        ],
        implementationCode: `
            const { synergyCombination, ...rest } = args;
            
            const gameParameters = {};
            for (const key in rest) {
                if (rest[key] !== null && rest[key] !== undefined) {
                    gameParameters[key] = rest[key];
                }
            }

            // FIX: Ensure synergyCombination is an array before using .join() and for the return value
            const finalCombination = Array.isArray(synergyCombination) ? synergyCombination : (synergyCombination ? [String(synergyCombination)] : []);

            if (finalCombination.length === 0 || (finalCombination.length === 1 && !finalCombination[0])) {
                throw new Error("A synergyCombination array is required.");
            }

            runtime.logEvent(\`[Game Data] Recording parameters for: \${finalCombination.join(' + ')}\`);

            return {
                success: true,
                synergyCombination: finalCombination,
                gameParameters,
            };
        `
    },
    {
        name: 'RecordTrialDossier',
        description: 'Records a complete, trial-ready dossier for a specific combination, intended for business and investment review.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To capture the structured output of the "Business Analyst" agent, turning research findings into an actionable investment proposal.',
        parameters: [
            { name: 'combination', type: 'array', description: 'The array of intervention objects, each with "name" and "type".', required: true },
            { name: 'executiveSummary', type: 'string', description: 'A high-level summary for investors.', required: true },
            { name: 'scientificRationale', type: 'string', description: 'Detailed explanation of the biological mechanism and synergy.', required: true },
            { name: 'inSilicoValidation', type: 'string', description: 'The results from the SynergyForge simulation, presented as evidence. E.g., "Predicted healthspan increase of 45% (p<0.001, n=1000) across 3 of 4 aging models."', required: true },
            { name: 'marketAndIP', type: 'string', description: 'Analysis of the market opportunity and potential for intellectual property.', required: true },
            { name: 'roadmap', type: 'string', description: 'Proposed next steps, e.g., preclinical animal studies.', required: true },
            { name: 'riskAnalysis', type: 'object', description: 'A structured object containing risk scores and a summary. Example: {"scientificRisk": 30, "commercialRisk": 50, "safetyRisk": 60, "overallRiskScore": 45, "riskSummary": "Primary risk is off-target effects..."}', required: true },
            { name: 'mitigationPlan', type: 'string', description: 'A concrete plan of action to de-risk the proposal (e.g., "Conduct advanced toxicology screens and a 12-month mouse study.").', required: true },
            { name: 'estimatedCostUSD', type: 'number', description: 'The estimated cost in USD to execute the mitigation plan.', required: true }
        ],
        implementationCode: `
            const { ...dossierData } = args;
            const { combination } = dossierData;
            
            if (!Array.isArray(combination) || combination.length === 0 || combination.some(c => typeof c !== 'object' || !c.name || !c.type)) {
                throw new Error("A dossier 'combination' is required and must be an array of objects, each with a 'name' and a 'type'.");
            }
            
            runtime.logEvent(\`[Dossier] Recording investment proposal for: \${combination.map(c => c.name).join(' + ')}\`);

            return {
                success: true,
                dossier: dossierData,
            };
        `
    },
    {
        name: 'RecordCritique',
        description: 'Records the structured output from the Critique Investment Proposal tool.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log the final critique of a proposal, making it available for the UI to display.',
        parameters: [
             { name: 'combination', type: 'array', description: 'The combination of intervention objects (with name and type) being critiqued.', required: true },
             { name: 'strengths', type: 'string', description: "A summary of the proposal's strong points.", required: true },
             { name: 'weaknesses', type: 'string', description: "A summary of the proposal's weaknesses and understated risks.", required: true },
             { name: 'contradictoryEvidence', type: 'array', description: 'An array of strings, where each string is a piece of evidence that contradicts the proposal.', required: true },
             { name: 'overallVerdict', type: 'string', description: 'The final verdict, must be one of: "Sound", "Needs Revision", or "High Risk".', required: true },
        ],
        implementationCode: `
            const { ...critiqueData } = args;
            const { combination } = critiqueData;

            if (!Array.isArray(combination) || combination.length === 0 || combination.some(c => typeof c !== 'object' || !c.name || !c.type)) {
                throw new Error("A critique 'combination' is required and must be an array of objects, each with a 'name' and a 'type'.");
            }
            
            if (!critiqueData.overallVerdict) {
                 throw new Error("Critique data is missing required field 'overallVerdict'.");
            }

            runtime.logEvent(\`[Critique] Recording critique for: \${combination.map(c => c.name).join(' + ')}\`);
            return { success: true, critique: critiqueData };
        `
    },
    {
        name: 'RecordErrorAnalysis',
        description: 'Records the structured analysis of a tool execution error, as determined by the diagnostic supervisor agent.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a clear, structured log entry detailing the root cause and suggested fix for a system error, enabling better debugging and future self-healing capabilities.',
        parameters: [
            { name: 'failedToolName', type: 'string', description: 'The name of the tool or process that failed.', required: true },
            { name: 'errorCategory', type: 'string', description: "The category of the error. Must be one of: 'MODEL_INCAPABLE', 'TOOL_BUG', 'PROMPT_AMBIGUITY', 'AGENT_LOGIC_ERROR'.", required: true },
            { name: 'diagnosis', type: 'string', description: 'A detailed explanation of the reasoning behind the diagnosis.', required: true },
            { name: 'suggestedAction', type: 'string', description: "The suggested recovery action. Must be one of: 'RETRY_WITH_STRONGER_MODEL', 'MODIFY_TOOL_CODE', 'REWRITE_PROMPT', 'SIMPLIFY_TASK'.", required: true },
            { name: 'actionParameters', type: 'object', description: 'A JSON object containing the specific parameters for the suggested action (e.g., {"suggestedModelId": "gemini-2.5-pro"}).', required: true },
        ],
        implementationCode: `
            const { failedToolName, errorCategory, diagnosis, suggestedAction, actionParameters } = args;
            
            const logMessage = \`
[SUPERVISOR] 💡 Diagnostic Report for '\${failedToolName}':
- Category: \${errorCategory}
- Action: \${suggestedAction}
- Parameters: \${JSON.stringify(actionParameters)}
- Diagnosis: \${diagnosis}
            \`;
            
            runtime.logEvent(logMessage);
            
            return {
                success: true,
                analysis: { failedToolName, errorCategory, diagnosis, suggestedAction, actionParameters }
            };
        `
    },
];
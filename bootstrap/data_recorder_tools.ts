



import type { ToolCreatorPayload } from '../types';

export const DATA_RECORDER_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'RecordHypothesis',
        description: 'Records a fully analyzed de novo hypothesis, including its abstract, cost analysis, and organ-specific impact.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a "venture-ready" hypothesis generated from a map vacancy into the main feed for prioritization and display.',
        parameters: [
            { name: 'hypotheticalAbstract', type: 'string', description: 'The generated abstract for the new research.', required: true },
            { name: 'neighbors', type: 'array', description: 'The neighboring research papers that inspired this hypothesis.', required: true },
            { name: 'estimatedCost', type: 'number', description: 'The estimated cost for in vitro validation.', required: true },
            { name: 'requiredAssays', type: 'array', description: 'The list of lab assays needed for validation.', required: true },
            { name: 'organImpacts', type: 'object', description: 'The predicted impact on organ-specific aging clocks.', required: true },
            { name: 'trialPriorityScore', type: 'number', description: 'A default scientific promise score for new hypotheses.', required: true },
            { name: 'experimentPlan', type: 'object', description: 'The detailed, step-by-step plan for the in vitro experiment.', required: false },
            { name: 'costBreakdown', type: 'array', description: 'An array of objects detailing the cost of each item in the experiment plan.', required: false },
        ],
        implementationCode: `
            const { ...hypothesisData } = args;
            runtime.logEvent(\`[Hypothesis Recorder] Recording new hypothesis. Est. cost: $\${hypothesisData.estimatedCost}\`);
            return {
                success: true,
                hypothesis: hypothesisData,
            };
        `
    },
    {
        name: 'RecordRefinedQueries',
        description: 'Records a list of specific search queries generated by the AI.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a list of search queries. This is called once by the query refinement agent.',
        parameters: [
            { name: 'queries', type: 'array', description: 'An array of specific, database-optimized search query strings.', required: true },
        ],
        implementationCode: `
            const { queries } = args;
            if (!queries || !Array.isArray(queries) || queries.length === 0) {
                throw new Error("An array of queries must be provided.");
            }
            runtime.logEvent(\`[Query Refinement] Recording \${queries.length} queries: \${queries.join('; ')}\`);
            return { success: true, queries };
        `
    },
    {
        name: 'RecordValidatedSource',
        description: 'Records the details of a single validated and summarized scientific source.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single validated source. This is called iteratively by the validation agent to build a list of trusted sources.',
        parameters: [
            { name: 'uri', type: 'string', description: 'The unique URL or identifier for the source.', required: true },
            { name: 'title', type: 'string', description: 'The title of the article.', required: true },
            { name: 'summary', type: 'string', description: 'A concise summary of the article\'s key findings relevant to the research objective.', required: true },
            { name: 'reliabilityScore', type: 'number', description: 'A score from 0.0 to 1.0 indicating the source\'s scientific reliability.', required: true },
            { name: 'justification', type: 'string', description: 'A brief justification for the assigned reliability score.', required: true },
        ],
        implementationCode: `
            const { ...validatedSourceData } = args;
            runtime.logEvent(\`[Validator] Recording validated source: \${validatedSourceData.title}\`);
            
            return {
                success: true,
                validatedSource: validatedSourceData
            };
        `
    },
    {
        name: 'RecordMetaAnalysis',
        description: 'Records that a specific source has been classified as a meta-analysis or review.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single source identified as a meta-analysis during the classification step.',
        parameters: [
            { name: 'source', type: 'object', description: 'The full source object that has been identified as a meta-analysis.', required: true },
        ],
        implementationCode: `
            const { source } = args;
            runtime.logEvent(\`[Classifier] Recording Meta-Analysis: \${source.title}\`);
            return { success: true, metaAnalysis: source };
        `
    },
    {
        name: 'RecordPrimaryStudy',
        description: 'Records that a specific source has been classified as a primary study.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single source identified as a primary study during the classification step.',
        parameters: [
            { name: 'source', type: 'object', description: 'The full source object that has been identified as a primary study.', required: true },
        ],
        implementationCode: `
            const { source } = args;
            runtime.logEvent(\`[Classifier] Recording Primary Study: \${source.title}\`);
            return { success: true, primaryStudy: source };
        `
    },
    {
        name: 'RecordSynergy',
        description: 'Records the details of a single synergistic intervention, including MoA and Theory Alignment scores.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log a single identified synergy with its complete scoring profile, which the agent calls iteratively.',
        parameters: [
            { name: 'combination', type: 'array', description: 'An array of objects, each with "name" and "type". Types are "drug" (molecules, wetware), "device" (hardware, nanorobots), or "behavior" (algorithms, lifestyle). E.g., [{"name": "Metformin", "type": "drug"}, {"name": "Exercise", "type": "behavior"}]', required: true },
            { name: 'status', type: 'string', description: 'The status of the synergy, either "Known" or "Hypothesized".', required: true },
            { name: 'synergyType', type: 'string', description: 'The type of interaction, e.g., "Synergistic", "Additive", "Antagonistic".', required: true },
            { name: 'summary', type: 'string', description: 'A brief explanation of the synergistic interaction and the rationale behind it.', required: true },
            { name: 'potentialRisks', type: 'string', description: 'A clear description of potential risks, side effects, or contraindications of the combination.', required: true },
            { name: 'sourceUri', type: 'string', description: 'The URI of the source document where this synergy was found.', required: false },
            { name: 'sourceTitle', type: 'string', description: 'The title of the source document.', required: false },
            { name: 'moaComplementarityScore', type: 'number', description: 'A score from 0-100 representing how well the mechanisms of action complement each other. Provide 0 if not applicable.', required: false },
            { name: 'moaJustification', type: 'string', description: 'A brief scientific justification for the complementarity score. Provide "N/A" if not applicable.', required: false },
            { name: 'trialPriorityScore', type: 'number', description: 'The final calculated score (0-100) indicating the priority for a clinical trial.', required: false },
            { name: 'theoryAlignmentScores', type: 'object', description: 'An object containing scores for alignment with different aging theories (e.g., {"stochastic": 80}).', required: false },
            { name: 'organImpacts', type: 'object', description: 'An object containing predicted impacts on organ-specific aging clocks.', required: false },
            { name: 'estimatedCost', type: 'number', description: 'The estimated first-pass cost for in vitro validation.', required: false },
            { name: 'costBreakdown', type: 'array', description: 'An array of objects detailing the cost of each item for validation.', required: false },
        ],
        implementationCode: `
            const { combination, status, synergyType, summary, potentialRisks, sourceUri, sourceTitle, moaComplementarityScore, moaJustification, trialPriorityScore, theoryAlignmentScores, organImpacts, estimatedCost, costBreakdown } = args;

            if (!Array.isArray(combination) || combination.length === 0 || combination.some(c => typeof c !== 'object' || !c.name || !c.type)) {
                throw new Error("A synergy 'combination' is required and must be an array of objects, each with a 'name' and a 'type'.");
            }

            runtime.logEvent(\`[Synergy Analysis] Recording synergy: \${combination.map(c => c.name).join(' + ')}\`);
            
            return {
                success: true,
                synergy: {
                    combination,
                    status,
                    synergyType,
                    summary,
                    potentialRisks,
                    sourceUri,
                    sourceTitle,
                    moaComplementarityScore: moaComplementarityScore || 0,
                    moaJustification: moaJustification || 'N/A',
                    trialPriorityScore: trialPriorityScore || 0,
                    theoryAlignmentScores: theoryAlignmentScores || {},
                    organImpacts: organImpacts || {},
                    estimatedCost: estimatedCost || 0,
                    costBreakdown: costBreakdown || [],
                }
            };
        `
    },
    {
        name: 'RecordSynergyGameParameters',
        description: 'Records the mapping of a single synergy to the specific parameters of the Organoid Odyssey simulator.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log the game parameters for a single synergy by calling a tool with explicit, flattened parameters, which is more reliable for AI.',
        parameters: [
            { name: 'synergyCombination', type: 'array', description: 'The array of intervention names that identifies the synergy (e.g., ["Metformin", "Rapamycin"]).', required: true },
            { name: 'senolytic_clearance', type: 'number', description: 'Value from 0.0 to 100.0 representing senescent cell clearance.', required: false },
            { name: 'autophagy_boost', type: 'number', description: 'Multiplier for autophagy effectiveness (e.g., 1.2 for a 20% boost).', required: false },
            { name: 'antioxidant_capacity_boost', type: 'number', description: 'Multiplier for antioxidant capacity (e.g., 1.5 for a 50% boost).', required: false },
            { name: 'dna_repair_rate_boost', type: 'number', description: 'Multiplier for DNA repair rate (e.g., 1.1 for a 10% boost).', required: false },
            { name: 'epigenetic_reset_value', type: 'number', description: 'Value from 0.0 to 100.0 for direct reduction in epigenetic noise.', required: false },
            { name: 'epigenetic_stabilization', type: 'number', description: 'Multiplier for epigenetic stability (e.g., 1.2 for a 20% improvement).', required: false },
            { name: 'signaling_pathway_inhibition', type: 'number', description: 'Multiplier for inhibiting harmful developmental signals (e.g., 1.15 for 15% inhibition).', required: false },
            { name: 'synaptic_density_boost', type: 'number', description: 'Value from 0.0 to 100.0 for direct increase in synaptic density.', required: false },
            { name: 'toxicity_impact', type: 'number', description: 'Value from 0.0 to 100.0 representing the negative health impact or toxicity.', required: false },
            { name: 'myelin_repair_boost', type: 'number', description: 'Multiplier for myelin repair processes (e.g., 1.3 for a 30% boost).', required: false },
            { name: 'neurotransmitter_stabilization', type: 'number', description: 'Multiplier for neurotransmitter balance and efficiency (e.g., 1.2 for 20% improvement).', required: false },
            { name: 'dendritic_arborization_factor', type: 'number', description: 'Value from 0.0 to 100.0 for direct increase in dendritic complexity.', required: false },
        ],
        implementationCode: `
            const { synergyCombination, ...rest } = args;
            
            const gameParameters = {};
            for (const key in rest) {
                if (rest[key] !== null && rest[key] !== undefined) {
                    gameParameters[key] = rest[key];
                }
            }

            // FIX: Ensure synergyCombination is an array before using .join() and for the return value
            const finalCombination = Array.isArray(synergyCombination) ? synergyCombination : (synergyCombination ? [String(synergyCombination)] : []);

            if (finalCombination.length === 0 || (finalCombination.length === 1 && !finalCombination[0])) {
                throw new Error("A synergyCombination array is required.");
            }

            runtime.logEvent(\`[Game Data] Recording parameters for: \${finalCombination.join(' + ')}\`);

            return {
                success: true,
                synergyCombination: finalCombination,
                gameParameters,
            };
        `
    },
    {
        name: 'RecordTrialDossier',
        description: 'Records a complete Risk Engineering Dossier for a specific combination, intended for business and investment review. Supports versioning.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To capture the structured output of the Risk Engineering agent, turning a raw hypothesis into an actionable, de-risked R&D project.',
        parameters: [
            { name: 'synergyData', type: 'object', description: 'The original synergy object, containing combination, summary, scores, etc.', required: true },
            { name: 'noveltyClass', type: 'string', description: 'The classification of the synergy\'s novelty (e.g., "DE NOVO HYPOTHESIS").', required: true },
            { name: 'riskDossier', type: 'array', description: 'The detailed array of identified risks and their engineering mitigation plans.', required: true },
            { name: 'commercializationOutlook', type: 'object', description: 'A structured object containing the full commercial analysis, including target indication, market data, and IP strategy.', required: false },
            { name: 'version', type: 'number', description: 'The version number for this dossier (e.g., 1, 2, 3).', required: false },
            { name: 'history', type: 'array', description: 'An array of strings describing the changelog for this dossier.', required: false },
            { name: 'backgroundSources', type: 'array', description: 'The list of sources used for analysis.', required: false },
        ],
        implementationCode: `
            const { synergyData, noveltyClass, riskDossier, commercializationOutlook, version, history, backgroundSources } = args;
            const { combination } = synergyData;
            
            if (!Array.isArray(combination) || combination.length === 0 || combination.some(c => typeof c !== 'object' || !c.name || !c.type)) {
                throw new Error("A valid 'synergyData.combination' is required.");
            }
             if (!noveltyClass || !riskDossier) {
                throw new Error("Missing required fields: 'noveltyClass' and 'riskDossier'.");
            }
            
            runtime.logEvent(\`[Dossier] Recording Risk Engineering Dossier v\${version || 1} for: \${combination.map(c => c.name).join(' + ')}\`);

            const fullDossier = {
                combination: synergyData.combination,
                synergyData,
                noveltyClass,
                riskDossier,
                ...(commercializationOutlook || {}),
                version: version || 1,
                history: history || [],
                backgroundSources: backgroundSources || [],
                updatedAt: new Date().toISOString(),
            };

            return {
                success: true,
                dossier: fullDossier,
            };
        `
    },
    {
        name: 'RecordCritique',
        description: 'Records the structured output from the Critique Investment Proposal tool.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To log the final critique of a proposal, making it available for the UI to display.',
        parameters: [
             { name: 'combination', type: 'array', description: 'The combination of intervention objects (with name and type) being critiqued.', required: true },
             { name: 'strengths', type: 'string', description: "A summary of the proposal's strong points.", required: true },
             { name: 'weaknesses', type: 'string', description: "A summary of the proposal's weaknesses and understated risks.", required: true },
             { name: 'contradictoryEvidence', type: 'array', description: 'An array of strings, where each string is a piece of evidence that contradicts the proposal.', required: true },
             { name: 'overallVerdict', type: 'string', description: 'The final verdict, must be one of: "Sound", "Needs Revision", or "High Risk".', required: true },
        ],
        implementationCode: `
            const { ...critiqueData } = args;
            const { combination } = critiqueData;

            if (!Array.isArray(combination) || combination.length === 0 || combination.some(c => typeof c !== 'object' || !c.name || !c.type)) {
                throw new Error("A critique 'combination' is required and must be an array of objects, each with a 'name' and a 'type'.");
            }
            
            if (!critiqueData.overallVerdict) {
                 throw new Error("Critique data is missing required field 'overallVerdict'.");
            }

            runtime.logEvent(\`[Critique] Recording critique for: \${combination.map(c => c.name).join(' + ')}\`);
            return { success: true, critique: critiqueData };
        `
    },
    {
        name: 'RecordErrorAnalysis',
        description: 'Records the structured analysis of a tool execution error, as determined by the diagnostic supervisor agent.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a clear, structured log entry detailing the root cause and suggested fix for a system error, enabling better debugging and future self-healing capabilities.',
        parameters: [
            { name: 'failedToolName', type: 'string', description: 'The name of the tool or process that failed.', required: true },
            { name: 'errorCategory', type: 'string', description: "The category of the error. Must be one of: 'MODEL_INCAPABLE', 'TOOL_BUG', 'PROMPT_AMBIGUITY', 'AGENT_LOGIC_ERROR'.", required: true },
            { name: 'diagnosis', type: 'string', description: 'A detailed explanation of the reasoning behind the diagnosis.', required: true },
            { name: 'suggestedAction', type: 'string', description: "The suggested recovery action. Must be one of: 'RETRY_WITH_STRONGER_MODEL', 'MODIFY_TOOL_CODE', 'REWRITE_PROMPT', 'SIMPLIFY_TASK'.", required: true },
            { name: 'actionParameters', type: 'object', description: 'A JSON object containing the specific parameters for the suggested action (e.g., {"suggestedModelId": "gemini-2.5-pro"}).', required: true },
        ],
        implementationCode: `
            const { failedToolName, errorCategory, diagnosis, suggestedAction, actionParameters } = args;
            
            const logMessage = \`
[SUPERVISOR] 💡 Diagnostic Report for '\${failedToolName}':
- Category: \${errorCategory}
- Action: \${suggestedAction}
- Parameters: \${JSON.stringify(actionParameters)}
- Diagnosis: \${diagnosis}
            \`;
            
            runtime.logEvent(logMessage);
            
            return {
                success: true,
                analysis: { failedToolName, errorCategory, diagnosis, suggestedAction, actionParameters }
            };
        `
    },
];